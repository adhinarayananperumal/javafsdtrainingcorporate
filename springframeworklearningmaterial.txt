The Spring Framework (Spring) is an open-source application framework that provides infrastructure support for 
developing Java applications. One of the most popular Java Enterprise Edition (Java EE) frameworks, Spring helps 
developers create high performing applications using plain old Java objects (POJOs).  

A framework is a large body of predefined code to which developers can add code to solve a problem in a specific 
domain. There are many popular Java frameworks including Java Server Faces (JSF), Maven, Hibernate, Struts, and Spring.

Spring removes tedious configuration work so that developers can focus on writing business logic.

Some of the most important features of the Spring framework are as follows:

IoC container
AOP
Data Access Framework - Spring DAO - JDBC abstraction layer
Spring MVC
Transaction Management
Spring Web Services
Spring TestContext framework


https://searchapparchitecture.techtarget.com/definition/Spring-Framework

IOC
	Spring IoC Container is the core of Spring Framework. It creates the objects, configures and assembles their dependencies, 
manages their entire life cycle. 

The advantages of this architecture are:
	1. Making it easier to switch between different implementations
	2.greater ease in testing a program by isolating a component or mocking its dependencies, and allowing components
	 to communicate through contracts




Dependency injection:
	Spring’s core logic is dependency injection. Dependency injection is a programming pattern that allows developers 
to build more decoupled architectures. Dependency injection means that Spring understands the different Java annotations 
that a developer puts on top of classes. Spring knows that the developer wants to create an instance of a class and that 
Spring should manage it. Spring also understands the dependency and makes sure that all instances created have properly 
populated dependencies.
For the Spring Framework to instantiate objects and populate the dependencies, a programmer 
simply tells Spring which objects to manage and what the dependencies are for each class.





IOC Containers
The org.springframework.beans and org.springframework.context packages are the basis for Spring Framework's IoC container.
 
The BeanFactory interface provides an advanced configuration mechanism capable of managing any type of object.

 ApplicationContext is a sub-interface of BeanFactory.
 It adds easier integration with Spring's AOP features; message resource handling (for use in internationalization), event 
publication; and application-layer specific contexts such as the WebApplicationContext for use in web applications.

In short, the BeanFactory provides the configuration framework and basic functionality, and the ApplicationContext adds more
 enterprise-specific functionality. The ApplicationContext is a complete superset of the BeanFactory, and is used exclusively 
in this chapter in descriptions of Spring's IoC container.

Several implementations of the ApplicationContext interface are supplied out-of-the-box with Spring.
 In standalone applications it is common to create an instance of ClassPathXmlApplicationContext or 
FileSystemXmlApplicationContext. 



Samples of Configuration bean in configuration file
1. XML Based
2. Java-based configuration

servicedao.xml
  <bean id="petStore"
        class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl">
    <property name="accountDao" ref="accountDao"/>
    <property name="itemDao" ref="itemDao"/>
    <!-- additional collaborators and configuration for this bean go here -->
  </bean>

  <bean id="accountDao"
      class="org.springframework.samples.jpetstore.dao.ibatis.SqlMapAccountDao">
    <!-- additional collaborators and configuration for this bean go here -->
  </bean>

  <bean id="itemDao" class="org.springframework.samples.jpetstore.dao.ibatis.SqlMapItemDao">
    <!-- additional collaborators and configuration for this bean go here -->
  </bean>

-------------------

import org.springframework.context.annotation.*;

@Configuration
public class HelloWorldConfig {
   @Bean 
   public HelloWorld helloWorld(){
      return new HelloWorld();
   }

@Bean 
   public HelloWorld customerService(){
      return new CustomerServiceImpl();
   }
}
The above code will be equivalent to the following XML configuration −

<beans>
   <bean id = "helloWorld" class = "com.tutorialspoint.HelloWorld" />
</beans>

<beans>
   <bean id = "customerService" class = "com.tutorialspoint.CustomerServiceImpl" />
</beans>


public static void main(String[] args) {
   ApplicationContext ctx = new AnnotationConfigApplicationContext(HelloWorldConfig.class);
   
   HelloWorld helloWorld = ctx.getBean(HelloWorld.class);
   helloWorld.setMessage("Hello World!");
   helloWorld.getMessage();
}
You can load various configuration classes as follows −

public static void main(String[] args) {
   AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();

   ctx.register(AppConfig.class, OtherConfig.class);
   ctx.register(AdditionalConfig.class);
   ctx.refresh();



-----------------------------------------------------------------------

ApplicationContext context =
    new ClassPathXmlApplicationContext(new String[] {"services.xml", "daos.xml"});

// retrieve configured instance
PetStoreServiceImpl service = context.getBean("petStore", PetStoreServiceImpl.class);

// use configured instance
List userList = service.getUsernameList();


Using @ComponentScan in a Spring Application
With Spring, we use the @ComponentScan annotation along with the @Configuration annotation to specify the packages 
that we want to be scanned. @ComponentScan without arguments tells Spring to scan the current package and all of its sub-packages.




@Configuration
@ComponentScan(basePackages = "com.bankad.service")
public class SpringComponentScanApp {
    private static ApplicationContext applicationContext;

    @Bean
    public ExampleBean exampleBean() {
        return new ExampleBean();
    }

    public static void main(String[] args) {
        applicationContext = 
          new AnnotationConfigApplicationContext(SpringComponentScanApp.class);

        for (String beanName : applicationContext.getBeanDefinitionNames()) {
            System.out.println(beanName);
        }
    }
}

Spring @Configuration annotation is part of the spring core framework. Spring Configuration annotation indicates that the
class has @Bean definition methods. So Spring container can process the class and generate Spring Beans to be used in the application.
Spring container to generate bean definitions and service requests for those beans at runtime

With @Component, @Repository, @Service and @Controller annotations in place and automatic component scanning enabled, 
Spring will automatically import the beans into the container and inject to dependencies. 
These annotations are called Stereotype annotations as well.


1.2. @Repository annotation
Although above use of @Component is good enough but we can use more suitable annotation that provides additional benefits
 specifically for DAOs i.e. @Repository annotation. The @Repository annotation is a specialization of the @Component annotation 
with similar use and functionality. In addition to importing the DAOs into the DI container, it also makes the unchecked exceptions (thrown from DAO methods) eligible for translation into Spring DataAccessException.

1.3. @Service annotation
The @Service annotation is also a specialization of the component annotation. It doesn’t currently provide any additional 
behavior over the @Component annotation, but it’s a good idea to use @Service over @Component in service-layer classes 
because it specifies intent better. Additionally, tool support and additional behavior might rely on it in the future.

1.4. @Controller annotation
@Controller annotation marks a class as a Spring Web MVC controller. It too is a @Component specialization, so beans marked 
with it are automatically imported into the DI container. When we add the @Controller annotation to a class, we can use another 
annotation i.e. @RequestMapping; to map URLs to instance methods of a class.

 @Component should be used when the class does not fall into either of three categories i.e. controller, serviceand dao.

@Configuration,
@EnableAutoConfiguration,
@ComponentScan.
After enabling annotation injection, we can use autowiring on properties, setters, and constructors.

Bean Scope
The scope of a bean defines the life cycle and visibility of that bean in the contexts we use it.
The latest version of the Spring framework defines 6 types of scopes:
singleton
prototype
request
session
application
websocket
The last four scopes mentioned, request, session, application and websocket, are only available in a web-aware application.

2. Singleton Scope
When we define a bean with the singleton scope, the container creates a single instance of that bean; all requests for that bean name will return the same object, which is cached. Any modifications to the object will be reflected in all references to the bean. This scope is the default value if no other scope is specified.


Let's create a Person entity to exemplify the concept of scopes:

public class Person {
    private String name;

    // standard constructor, getters and setters
}
Afterwards, we define the bean with the singleton scope by using the @Scope annotation:

@Bean
@Scope("singleton")
public Person personSingleton() {
    return new Person();
}

Prototype Scope
A bean with the prototype scope will return a different instance every time it is requested from the container. It is defined by setting the value prototype to the @Scope annotation in the bean definition:

@Bean
@Scope("prototype")
public Person personPrototype() {
    return new Person();
}
We can also use a constant like we did for the singleton scope:

@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)

Enabling @Autowired Annotations
The Spring framework enables automatic dependency injection. In other words, by declaring all the bean dependencies in a 
Spring configuration file, Spring container can autowire relationships between collaborating beans. This is called Spring 
bean autowiring.



Web MVC framework
Introduction to Spring Web MVC framework
The Spring Web model-view-controller (MVC) framework is designed around a DispatcherServlet that dispatches requests to handlers,
 with configurable handler mappings, view resolution, locale and theme resolution as well as support for uploading files. 
The default handler is based on the @Controller and @RequestMapping annotations, offering a wide range of flexible handling methods.
 With the introduction of Spring 3.0, the @Controller mechanism also allows you to create RESTful Web sites and applications,
 through the @PathVariable annotation and other features.



DispatcherServlet
Spring's web MVC framework is, like many other web MVC frameworks, request-driven, designed around a central Servlet that 
dispatches requests to controllers and offers other functionality that facilitates the development of web applications. 
Spring's DispatcherServlet however, does more than just that. It is completely integrated with the 
Spring IoC container and as such allows you to use every other feature that Spring has.

<web-app>

    <servlet>
        <servlet-name>example</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <load-on-startup>1</load-on-startup>
    </servlet>

    <servlet-mapping>
        <servlet-name>example</servlet-name>
        <url-pattern>/example/*</url-pattern>
    </servlet-mapping>

</web-app>


In a Servlet 3.0+ environment, you also have the option of configuring the Servlet container programmatically. 
Below is the code based equivalent of the above web.xml example:

public class MyWebApplicationInitializer implements WebApplicationInitializer {

    @Override
    public void onStartup(ServletContext container) {
        ServletRegistration.Dynamic registration = container.addServlet("dispatcher", new DispatcherServlet());
        registration.setLoadOnStartup(1);
        registration.addMapping("/example/*");
    }

}

WebApplicationInitializer is an interface provided by Spring MVC that ensures your code-based configuration is detected and 
automatically used to initialize any Servlet 3 container. 
An abstract base class implementation of this interace named AbstractDispatcherServletInitializer makes it even easier to 
register the DispatcherServlet by simply specifying its servlet mapping. 

The above is only the first step in setting up Spring Web MVC. You now need to configure the various beans used by the 
Spring Web MVC framework (over and above the DispatcherServlet itself).

HandlerMapping	Maps incoming requests to handlers and a list of pre- and post-processors (handler interceptors)
 based on some criteria the details of which vary by HandlerMapping implementation.
 The most popular implementation supports annotated controllers but other implementations exists as well.

HandlerAdapter	Helps the DispatcherServlet to invoke a handler mapped to a request regardless of the handler is actually invoked. 
For example, invoking an annotated controller requires resolving various annotations. Thus the main purpose of a HandlerAdapter 
is to shield the DispatcherServlet from such details.


ViewResolver	Resolves logical String-based view names to actual View types.


DispatcherServlet Processing Sequence
After you set up a DispatcherServlet, and a request comes in for that specific DispatcherServlet, the DispatcherServlet 
starts processing the request as follows:

The WebApplicationContext is searched for and bound in the request as an attribute that the controller and other elements 
in the process can use. It is bound by default under the key DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE.

The locale resolver is bound to the request to enable elements in the process to resolve the locale to use when processing 
the request (rendering the view, preparing data, and so on). If you do not need locale resolving, you do not need it.

The theme resolver is bound to the request to let elements such as views determine which theme to use. If you do not use themes, 
you can ignore it.

If you specify a multipart file resolver, the request is inspected for multiparts; if multiparts are found, the request 
is wrapped in a MultipartHttpServletRequest for further processing by other elements in the process.


An appropriate handler is searched for. If a handler is found, the execution chain associated with the handler 
(preprocessors, postprocessors, and controllers) is executed in order to prepare a model or rendering.

If a model is returned, the view is rendered. If no model is returned, (may be due to a preprocessor or postprocessor intercepting the request, perhaps for security reasons), no view is rendered, because the request could already have been fulfilled.

Handler exception resolvers that are declared in the WebApplicationContext pick up exceptions that are thrown during processing 
of the request. Using these exception resolvers allows you to define custom behaviors to address exceptions.

The Spring DispatcherServlet also supports the return of the last-modification-date, as specified by the Servlet API. 
The process of determining the last modification date for a specific request is straightforward: the DispatcherServlet looks up 
an appropriate handler mapping and tests whether the handler that is found implements the LastModified interface. If so, the value of the long getLastModified(request) method of the LastModified interface is returned to the client.

You can customize individual DispatcherServlet instances by adding Servlet initialization parameters (init-param elements) 
to the Servlet declaration in the web.xml


@Controller
public class HelloWorldController {

    @RequestMapping("/helloWorld")
    public String helloWorld(Model model) {
        model.addAttribute("message", "Hello World!");
        return "helloWorld";
    }
}


The @Controller annotation indicates that a particular class serves the role of a controller. Spring does not require you
 to extend any controller base class or reference the Servlet API. However, you can still reference Servlet-specific features 
if you need to.

The @Controller annotation acts as a stereotype for the annotated class, indicating its role. The dispatcher scans such 
annotated classes for mapped methods and detects @RequestMapping annotations (see the next section).

When a @PathVariable annotation is used on a Map<String, String> argument, the map is populated with all URI template variables.

A URI template can be assembled from type and path level @RequestMapping annotations. As a result the findPet() method can be invoked with a URL such as /owners/42/pets/21.

@Controller
@RequestMapping("/owners/{ownerId}")
public class RelativePathUriTemplateController {

  @RequestMapping("/pets/{petId}")
  public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) {
    // implementation omitted
  }
}
A @PathVariable argument can be of any simple type such as int, long, Date, etc. Spring automatically converts to the appropriate
 type or throws a TypeMismatchException if it fails to do so. You can also register support for parsing additional data types

If the method is annotated with @ResponseBody, the return type is written to the response HTTP body. The return value will be 
converted to the declared method argument type using HttpMessageConverters. See the section called “Mapping the response body 
with the @ResponseBody annotation”.

A HttpEntity<?> or ResponseEntity<?> object to provide access to the Servlet response HTTP headers and contents. 
The entity body will be converted to the response stream using HttpMessageConverters. See the section called “Using HttpEntity<?>”.

Binding request parameters to method parameters with @RequestParam
Use the @RequestParam annotation to bind request parameters to a method parameter in your controller.

Mapping the request body with the @RequestBody annotation
The @RequestBody method parameter annotation indicates that a method parameter should be bound to the value of the HTTP request body. For example:

@RequestMapping(value = "/something", method = RequestMethod.PUT)
public void handle(@RequestBody String body, Writer writer) throws IOException {
  writer.write(body);
}


Mapping the response body with the @ResponseBody annotation
The @ResponseBody annotation is similar to @RequestBody. This annotation can be put on a method and indicates that the return type should be written straight to the HTTP response body (and not placed in a Model, or interpreted as a view name). For example:

@RequestMapping(value = "/something", method = RequestMethod.PUT)
@ResponseBody
public String helloWorld()  {
  return "Hello World";
}
The above example will result in the text Hello World being written to the HTTP response stream.

As with @RequestBody, Spring converts the returned object to a response body by using an HttpMessageConverter



Rest Controller
Spring RestController annotation is a convenience annotation that is itself annotated with @Controller and @ResponseBody. 
This annotation is applied to a class to mark it as a request handler.

Spring RestController annotation is used to create RESTful web services using Spring MVC. 
Spring RestController takes care of mapping request data to the defined request handler method. Once response body is generated 
from the handler method, it converts it to JSON or XML response.

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

import com.journaldev.spring.model.Employee;
import com.journaldev.spring.repository.EmployeeRepository;

@RestController
public class EmployeeRestController {

	@Autowired
	private EmployeeRepository repository;
	
	@GetMapping("/rest/employee/get/{id}")
	public Employee getEmployeeByID(@PathVariable("id") int id) {
		return repository.retrieve(id);
	}
	
	@GetMapping("/rest/employee/getAll")
	//Returning is List is supported with JSON response only
	//If you want XML, then add a wrapper class as Root XML element, for example EmployeeList
	public List<Employee> getAllEmployees() {
		return repository.getAll();
	}

	@PostMapping("/rest/employee/create")
	public Employee createEmployee(@RequestBody Employee emp) {
		repository.store(emp);
		return emp;
	}
	
	@GetMapping("/rest/employee/search/{name}")
	public Employee getEmployeeByName(@PathVariable("name") String name) {
		return repository.search(name);
	}
	
	@DeleteMapping("/rest/employee/delete/{id}")
	public Employee deleteEmployeeByID(@PathVariable("id") int id) {
		return repository.delete(id);
	}
}

PUT method is idempotent. So if we retry a request multiple times, that should be equivalent to a single request invocation.
Use PUT when we want to modify a singular resource that is already a part of resources collection.
PUT replaces the resource in its entirety. Use PATCH if request updates part of the resource.

The POST method is used to request that the origin server accept the entity attached in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line.
It essentially means that POST request-URI should be of a collection URI.
POST /questions
POST is NOT idempotent. So if we retry the request N times, we will end up having N resources with N different URIs created on
 the server.


GET 	/device-management/devices       : Get all devices
POST 	/device-management/devices       : Create a new device
GET 	/device-management/devices/{id}   : Get the device information identified by "id"
PUT 	/device-management/devices/{id}   : Update the device information identified by "id"
DELETE	/device-management/devices/{id}   : Delete device by "id"




Spring Boot

Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can "just run".
We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. 
Most Spring Boot applications need minimal Spring configuration.

Features
Create stand-alone Spring applications
Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files)
Provide opinionated 'starter' dependencies to simplify your build configuration
Automatically configure Spring and 3rd party libraries whenever possible
Provide production-ready features such as metrics, health checks, and externalized configuration
Absolutely no code generation and no requirement for XML configuration


Spring Boot provides a number of starters that allow us to add jars in the classpath. Spring Boot built-in starters
make development easier and rapid. Spring Boot Starters are the dependency descriptors.

Spring Boot Starters
In the Spring Boot Framework, all the starters follow a similar naming pattern: spring-boot-starter-*, where * denotes 
a particular type of application. For example, if we want to use Spring and JPA for database access, we need to include the 
spring-boot-starter-data-jpa dependency in our pom.xml file of the project.



Spring Boot Starter Web
There are two important features of spring-boot-starter-web:
It is compatible for web development
Auto configuration
If we want to develop a web application, we need to add the following dependency in pom.xml file:
<dependency>  
<groupId>org.springframework.boot</groupId>  
<artifactId>spring-boot-starter-web</artifactId>  
<version>2.2.2.RELEASE</version>  
</dependency>  

Spring Boot Starter Parent
The spring-boot-starter-parent is a project starter. It provides default configurations for our applications. 
It is used internally by all dependencies. All Spring Boot projects use spring-boot-starter-parent as a parent in pom.xml file.
<parent>  
<groupId>org.springframework.boot</groupId>  
<artifactId>spring-boot-starter-parent</artifactId>  
<version>1.4.0.RELEASE</version>  
</parent>  


Using the @SpringBootApplication Annotation
Many Spring Boot developers like their apps to use auto-configuration, component scan and be able to define extra 
configuration on their "application class". A single @SpringBootApplication annotation can be used to enable those three
 features, that is:

@EnableAutoConfiguration: enable Spring Boot’s auto-configuration mechanism
@ComponentScan: enable @Component scan on the package where the application is located (see the best practices)
@Configuration: allow to register extra beans in the context or import additional configuration classes
The @SpringBootApplication annotation is equivalent to using @Configuration, @EnableAutoConfiguration, and @ComponentScan
with their default attributes, as shown in the following example:


import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}

}

Spring Data JPA
Spring Data JPA, part of the larger Spring Data family, makes it easy to easily implement JPA based repositories. 
This module deals with enhanced support for JPA based data access layers. It makes it easier to build Spring-powered applications 
that use data access technologies.

by implementing one of the Repository interfaces, the DAO will already have some basic CRUD methods (and queries) defined and implemented.

To define more specific access methods, Spring JPA supports quite a few options:

<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-data-jpa</artifactId>
   <version>2.5.11</version>
</dependency>


simply define a new method in the interface
provide the actual JPQL query by using the @Query annotation
use the more advanced Specification and Querydsl support in Spring Data
define custom queries via JPA Named Queries


public interface EmployeeDAO extends JpaRepository<Employee, Long> {
    Employee findByName(String name);
}


@Query("SELECT f FROM Foo f WHERE LOWER(f.name) = LOWER(:name)")
Foo retrieveByName(@Param("name") String name);

@Query("SELECT t.title FROM Todo t where t.id = :id") 
String findTitleById(@Param("id") Long id);
     
@Query("SELECT t.title FROM Todo t where t.id = :id") 
Optional<String> findTitleById(@Param("id") Long id);



Using Named Queries With Spring Data JPA
Before we can implement our search function, we have to understand how we can use named queries with Spring Data JPA. 
In other words, we have to find the answers to these questions:

How can we create named queries?
How can we create the query methods that invokes our named queries?
Creating Named Queries
We can specify named queries with Spring Data JPA by using a properties file, annotations, or the orm.xml file.

Before can take a closer look at these methods, we have to learn a few rules that we must follow when we are specifying the names of our named queries. These rules are:

If we want to use the default naming strategy of Spring Data JPA, we have to specify the name of the named query by using 
this syntax: [entity class name].[name of the invoked query method].
If we want to use some other syntax, we have to configure the name of named query when we create the query method that invokes it.
We can do this by using the name attribute of the @Query annotation.


Spring Microservices
Microservice architectures are the ‘new normal’. Building small, self-contained, ready to run applications can bring great 
flexibility and added resilience to your code. Spring Boot’s many purpose-built features make it easy to build and run your 
microservices in production at scale. 

Spring Cloud
Developing distributed systems can be challenging. Complexity is moved from the application layer to the network layer 
and demands greater interaction between services. Making your code ‘cloud-native’ means dealing with 12-factor issues such 
as external configuration, statelessness, logging, and connecting to backing services. The Spring Cloud suite of projects contains 
many of the services you need to make your applications run in the cloud.

The distributed nature of microservices brings challenges. Spring helps you mitigate these. 
With several ready-to-run cloud patterns, Spring Cloud can help with service discovery, load-balancing, 
circuit-breaking, distributed tracing, and monitoring. It can even act as an API gateway.


In the modern era, software is commonly delivered as a service: called web apps, or software-as-a-service. 
The twelve-factor app is a methodology for building software-as-a-service apps that:

Use declarative formats for setup automation, to minimize time and cost for new developers joining the project;
Have a clean contract with the underlying operating system, offering maximum portability between execution environments;
Are suitable for deployment on modern cloud platforms, obviating the need for servers and systems administration;
Minimize divergence between development and production, enabling continuous deployment for maximum agility;
And can scale up without significant changes to tooling, architecture, or development practices.
The twelve-factor methodology can be applied to apps written in any programming language, and which use any combination 
of backing services (database, queue, memory cache, etc).

The Twelve Factors
I. Codebase
One codebase tracked in revision control, many deploys
II. Dependencies
Explicitly declare and isolate dependencies
III. Config
Store config in the environment
IV. Backing services
Treat backing services as attached resources
V. Build, release, run
Strictly separate build and run stages
VI. Processes
Execute the app as one or more stateless processes
VII. Port binding
Export services via port binding
VIII. Concurrency
Scale out via the process model
IX. Disposability
Maximize robustness with fast startup and graceful shutdown
X. Dev/prod parity
Keep development, staging, and production as similar as possible
XI. Logs
Treat logs as event streams
XII. Admin processes
Run admin/management tasks as one-off processes



Service discovery
API gateway
Cloud config
Circuit breakers
Tracing


Service discovery
In the cloud, applications can’t always know the exact location of other services. A service registry, such as Netflix Eureka, 
or a sidecar solution, such as HashiCorp Consul, can help. Spring Cloud provides DiscoveryClient implementations for popular
registries such as Eureka, Consul, Zookeeper, and even Kubernetes' built-in system. There’s also a Spring Cloud Load Balancer to
help you distribute the load carefully among your service instances.


API gateway
With so many clients and servers in play, it’s often helpful to include an API gateway in your cloud architecture. 
A gateway can take care of securing and routing messages, hiding services, throttling load, and many other useful things. 
Spring Cloud Gateway gives you precise control of your API layer, integrating Spring Cloud service discovery and client-side 
load-balancing solutions to simplify configuration and maintenance.


Cloud configuration
In the cloud, configuration can’t simply be embedded inside the application. The configuration has to be flexible enough 
to cope with multiple applications, environments, and service instances, as well as deal with dynamic changes without downtime. 
Spring Cloud Config is designed to ease these burdens and offers integration with version control systems like Git to help you 
keep your configuration safe.

Circuit breakers
Distributed systems can be unreliable. Requests might encounter timeouts or fail completely. A circuit breaker can help 
mitigate these issues, and Spring Cloud Circuit Breaker gives you the choice of three popular options: Resilience4J, 
Sentinel, or Hystrix.


Tracing
Debugging distributed applications can be complex and take a long time. For any given failure, you might need to piece 
together traces of information from several independent services. Spring Cloud Sleuth can instrument your applications 
in a predictable and repeatable way. And when used in conjunction with Zipkin, you can zero in on any 
latency problems you might have.











